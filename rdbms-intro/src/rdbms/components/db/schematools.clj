(ns rdbms.components.db.schematools
  (:require [clojure.string :as str]
            [clojure.java.jdbc :as jdbc]
            [java-jdbc.ddl :as ddl]
            [java-jdbc.sql :as sql]))


;;; Concepts
;;; A schema is a vector of pairs where each pair has
;;;  - a keyword which is used as (lowercase) tablename.
;;;  - a vector of columns specs
;;; (It cannot be a map, because the order of tables creates and drops is important.)
;;;
;;; A column spec is a pair of keyword and String describing DB type
;;; and any constraints.



(def ^:private common-types
  {'id          "integer not null primary key"
   'string      "varchar(150)"
   'shortstring "varchar(50)"
   'longstring  "varchar(5000)"
   'blob        "blob"
   'integer     "integer"})


(def mysql-dialect (merge common-types
                          {'id "integer not null auto_increment primary key"}))

(def h2-dialect (merge common-types
                       {'id "integer generated by default as identity primary key"}))



(defn- translate
  [dialect [columnkey sym]]
  (if-let [spec (if (string? sym)
                  sym
                  (dialect sym))]
    [columnkey spec]
    (throw (IllegalArgumentException. (str "Unable to translate " sym)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Public API

(defn id-column
  "Returns a column spec for an auto-generated primary key column."
  ([]
   (id-column :id))
  ([id-kw]
   [id-kw 'id]))


(defn fk-column
  "Returns a column spec for a foreign key column that references a
  record in a different table."
  ([table owned?]
   (fk-column table (keyword (str (name table) "_id")) owned?))
  ([table column owned?]
   [column (str "integer"
                (if owned? " not null")
                (format " , foreign key (%s) references %s (id)" (name column) (name table))
                (if owned? " on delete cascade on update cascade"))]))


(defn schema->create-sql
  "Returns a sequence of CREATE TABLE statements as Strings from the
  given schema."
  [schema dialect]
  (->> schema
       (partition 2)
       (map (fn [[tablekey specs]]
              (->> specs
                   (map (partial translate dialect))
                   (apply ddl/create-table tablekey))))))


(defn schema->drop-sql
  "Returns a sequence of DROP TABLE statements (in reversed order) as
  String from the given schema."
  [schema]
  (->> schema
       (partition 2)
       (reverse)
       (map first)
       (map #(format "DROP TABLE IF EXISTS %s" (sql/as-str sql/as-is %)))))


(defn statements->text
  "Takes each statement, appends a ; and returns all statements joined
  to one big string."
  [statements]
  (->> statements (map #(str % ";")) (str/join "\n")))


(defn reset-schema!
  "Executes drop and create statements."
  [db-spec schema dialect]
  (jdbc/with-db-transaction [tx db-spec]
    (doseq [stmt (concat (schema->drop-sql schema)
                         (schema->create-sql schema dialect))]
      (jdbc/execute! tx [stmt]))))
